## This script reports and visualises the performance of the random forest
## regression models fitted in 3_quantile_regression.R. Parts 2-5 report model
## performance and variable importance. Part 6 compares spatial performance of
## rasters generated by 4a_rpi_map_predict.R and 4b_RESTREND.R.

## Guy Lomax
## G.Lomax@exeter.ac.uk
## 24th September 2024

## 1. Setup ----

source("scripts/load.R")

## 2. Load data and models ----

task_gpp <- read_rds("data/processed/rds/regr_task_gpp.rds")

rf_model_sp <- read_rds("data/processed/rds/rf_tuned_sp.rds")

# Country polygons for maps

ke_tz <- st_read("data/raw/vector/ne_10m_admin_0_countries/ne_10m_admin_0_countries.shp") %>%
  filter(NAME %in% c("Kenya", "Tanzania"))

## 3. Calculate model performance metrics ----

# Measures to evaluate model performance
measures <- msrs(c("regr.mae", "regr.rmse", "regr.rsq"))

rf_predictions_sp <- rf_model_sp$predict(task_gpp)

rf_predictions_sp$score(measures)

## 4. Visualise model fit ----

# Extract quantile predictions

rf_predictions_sp_qu <- predict(
  rf_model_sp$learner$model,
  task_gpp$data(),
  type = "quantiles",
  quantiles = 0.9
)

data_with_quantiles <- task_gpp$data() %>%
  bind_cols(rf_predictions_sp_qu$predictions) %>%
  rename(quantile_pred = "quantile= 0.9") %>%
  mutate(across(.cols = c("GPP", starts_with("quantile")), .fns = ~ .x / 1000))

# Plot distribution of model residuals (using 0.9 quantile) 
density_breaks <- c(1, 10, 100, 1000, 10000)

density_plot_sp <- ggplot(data_with_quantiles, aes(x = quantile_pred, y = GPP)) +
  geom_hex(bins = 60) +
  scale_fill_viridis_c(direction = 1, trans = "log", breaks = density_breaks) +
  geom_abline(slope = seq(0.2, 1, 0.2), intercept = 0, colour = "grey", lwd = 0.8, linetype = "longdash") +
  geom_abline(slope = 1, intercept = 0, colour = "grey", lwd = 1.6) +
  theme_classic() +
  theme(legend.position = c(0.18, 0.75), legend.key.height = unit(1.5, "cm"),
        axis.title = element_text(size = 24),
        axis.text = element_text(size = 16),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 16),
        legend.background = element_rect(fill = "transparent")) +
  xlim(0, 16) +
  ylim(0, 16) +
  labs(x = expression(atop("Potential GPP", (g~C~m^-2~yr^-1))),
       y = expression(atop("Actual GPP", (g~C~m^-2~yr^-1))),
       fill = "Number of points")

ggsave(
  "results/figures/density_plot_sp.png",
  density_plot_sp,
  width = 24, height = 24, units = "cm", dpi = 300
)

## 5. Variable importance ----

# Variable importance

importance_sp <- rf_model_sp$learner$importance()

static_vars <- c(
  "pptMean",
  "treeCover",
  "ECO_ID",
  "DEM",
  "slope",
  "merit_twi_fd8",
  "dist_to_river",
  "sand"
)
var_labels <- c(
  precipitation = "<i>Annual precipitation</i>",
  mean_ppt = "Mean annual precipitation",
  temperature_2m = "Mean annual temperature",
  pptIntensity = "Precipitation intensity",
  pptMeanDayAnomaly = "Anomaly in<br>mean precipitation day",
  GMT_0900_PAR = "Mean PAR",
  pptAnomaly = "Annual precipitation anomaly",
  potential_evaporation_sum = "Potential evapotranspiration",
  ugi = "Unranked Gini index",
  sand = "Soil sand fraction",
  treeCover = "Tree cover fraction",
  ECO_ID = "<i>Ecoregion</i>",
  DEM = "<i>Elevation</i>",
  slope = "Slope",
  distToRiver = "Distance to river",
  landform = "Landform",
  twi = "Topographic Wetness Index"
)

var_labels_df <- data.frame(variable = names(var_labels), label = unname(var_labels))

importance_df <- tibble(variable = names(importance_sp)) %>%
  mutate(importance_sp = importance_sp[variable],
         type = ifelse(variable %in% static_vars, "Static", "Annual")) %>%
  left_join(var_labels_df)

importance_plot <- importance_df %>%
  mutate(label = reorder(label, importance_sp)) %>%
  pivot_longer(starts_with("importance")) %>%
  ggplot(aes(x = value, y = label, colour = type)) +
  geom_point(size = 2) +
  scale_colour_manual(values = c("darkblue", "red")) +
  theme_bw() +
  labs(x = "Variable importance", y = "Variable", colour = "Variable type") +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 16),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 16),
        legend.position = "bottom",
        axis.text.y = ggtext::element_markdown())

ggsave(
  "results/figures/var_importance.png",
  importance_plot,
  width = 24, height = 20, units = "cm", dpi = 250
)

## 6. Spatial comparison with previous versions ----

# Load v1 and v2 RPI rasters and crop/mask to consistent spatial extent
rpi_rast_v2 <- rast("data/processed/raster/outputs/rpi_rast_v2.tif")
rpi_rast_v1 <- rast("data/raw/raster/rpi_rast_v1.tif")

rpi_rast_v1_crop <- rpi_rast_v1 %>%
  crop(rpi_rast_v2[[1]], extend = TRUE, mask = TRUE)

rpi_rast_v2_crop <- rpi_rast_v2 %>%
  mask(rpi_rast_v1_crop[[1]]) %>%
  subset(names(rpi_rast_v2)[names(rpi_rast_v2) %in% names(rpi_rast_v1)])

# # Calculate performance across shared pixel-year combinations
# 
# rpi_v2_df <- rpi_rast_v2_crop %>%
#   as.data.frame(cells = TRUE) %>%
#   tidy_annual_vars() %>%
#   drop_na()
# 
# rpi_v1_df <- rpi_rast_v1_crop %>%
#   as.data.frame(cells = TRUE) %>%
#   tidy_annual_vars() %>%
#   drop_na()
# 
# perf_v2 <- calc_performance(rpi_v2_df$GPP, rpi_v2_df$gpp_predicted)
# perf_v1 <- calc_performance(rpi_v1_df$GPP, rpi_v1_df$gpp_predicted)

# Calculate pixel-wise performance in explaining temporal extent

gpp_actual_v2 <- subset(rpi_rast_v2_crop, str_detect(names(rpi_rast_v2_crop), "GPP"))
gpp_pred_v2 <- subset(rpi_rast_v2_crop, str_detect(names(rpi_rast_v2_crop), regex("^gpp_predicted")))

# gpp_actual_v2_subset <- subset(rpi_rast_v2_crop, str_detect(names(rpi_rast_v2_crop), "GPP"))
# gpp_pred_v2_subset <- subset(rpi_rast_v2_crop, str_detect(names(rpi_rast_v2_crop), regex("^gpp_predicted")))

gpp_actual_v1 <- subset(rpi_rast_v1_crop, str_detect(names(rpi_rast_v1_crop), "GPP"))
gpp_pred_v1 <- subset(rpi_rast_v1_crop, str_detect(names(rpi_rast_v1_crop), regex("^gpp_predicted")))

# Load RESTREND raster for comparison
restrend <- rast("data/processed/raster/outputs/restrend.tif")
restrend_crop <- crop(restrend, gpp_actual_v2[[1]], mask = TRUE)[[1:nlyr(gpp_actual_v2)]]
restrend_preds <- gpp_actual_v2 - restrend_crop
names(restrend_preds) <- str_replace(names(restrend_resids), "resid", "pred")

perf_v2_temporal <- calc_performance_raster(gpp_actual_v2, gpp_pred_v2)
perf_v1_temporal <- calc_performance_raster(gpp_actual_v1, gpp_pred_v1)
perf_restrend_temporal <- calc_performance_raster(gpp_actual_v2, restrend_preds)


writeRaster(perf_v2_temporal,
            "data/processed/raster/performance/temporal_performance_v2.tif",
            overwrite = TRUE)
writeRaster(perf_v2_temporal,
            "data/processed/raster/performance/temporal_performance_old.tif",
            overwrite = TRUE)
writeRaster(perf_restrend_temporal,
            "data/processed/raster/performance/temporal_performance_restrend.tif",
            overwrite = TRUE)

# perf_v2_temporal <- rast("data/processed/raster/temporal_performance_v2.tif")
# perf_v1_temporal <- rast("data/processed/raster/temporal_performancev_v1.tif")
# perf_restrend_temporal <- rast("data/processed/raster/temporal_performance_restrend.tif")

# Plot performance metrics

performance_df <- as.data.frame(perf_v2_temporal, cells = TRUE) %>%
  rename_with(~ paste0(.x, ".v2"), -cell) %>%
  left_join(as.data.frame(perf_v1_temporal, cells = TRUE) %>% rename_with(~paste0(.x, ".v1"), -cell)) %>%
  left_join(as.data.frame(perf_restrend_temporal, cells = TRUE) %>% rename_with(~paste0(.x, ".restrend"), -cell)) %>%
  pivot_longer(-cell) %>%
  separate_wider_delim(name, ".", names = c("measure", "version")) %>%
  drop_na()

measure_labels <- as_labeller(c(mae = "Mean~Absolute~Error~(g~C~m^-2~yr^-1)", rmse = "RMSE", rsq = "R^2"), label_parsed)

temporal_performance_hist <- performance_df %>%
  filter(measure != "rmse") %>%
  mutate(version = ordered(version, levels = c("v1", "v2", "restrend"))) %>%
  arrange(version) %>%
  ggplot(aes(x = value, fill = version)) +
  geom_density(alpha = 0.6, kernel = "rectangular") +
  facet_wrap(~measure, ncol = 1, nrow = 3, scales = "free", labeller = measure_labels) +
  theme_bw() +
  scale_fill_brewer(palette = "Set1", labels = c("RPI v1", "RPI v2", "RESTREND")) +
  ggh4x::facetted_pos_scales(x = list(
    measure == "mae" ~ scale_x_continuous(limits = c(0, 1500)),
    measure == "rmse" ~ scale_x_continuous(limits = c(0, 1500)),
    measure == "rsq" ~ scale_x_continuous(limits = c(-0.5, 1))
  )) +
  geom_vline(xintercept = 0, colour = "grey10") +
  labs(x = "Value", y = "Density", fill = "Version")

# temporal_performance_hist_restrend <- performance_df_restrend %>%
#   filter(measure != "rmse") %>%
#   mutate(version = ordered(version, levels = c("restrend", "new_full"))) %>%
#   arrange(version) %>%
#   ggplot(aes(x = value, fill = version)) +
#   geom_density(alpha = 0.6, kernel = "rectangular") +
#   facet_wrap(~measure, ncol = 1, nrow = 3, scales = "free", labeller = measure_labels) +
#   theme_bw() +
#   scale_fill_brewer(palette = "Set1", labels = c("RESTREND", "RPI v2")) +
#   ggh4x::facetted_pos_scales(x = list(
#     measure == "mae" ~ scale_x_continuous(limits = c(0, 1500)),
#     measure == "rmse" ~ scale_x_continuous(limits = c(0, 1500)),
#     measure == "rsq" ~ scale_x_continuous(limits = c(-0.5, 1))
#   )) +
#   geom_vline(xintercept = 0, colour = "grey10") +
#   labs(x = "Value", y = "Density", fill = "Method")

ggsave("results/figures/rpi_version_performance_hist.png",
       temporal_performance_hist,
       width = 16, height = 16, units = "cm", dpi = 250)

# ggsave("results/figures/rpi_restrend_performance_hist.png",
#        temporal_performance_hist_restrend,
#        width = 16, height = 16, units = "cm", dpi = 250)

# Calculate overall performance in explaining spatial patterns in mean GPP

gpp_actual_v2_mean <- mean(gpp_actual_v2)
gpp_pred_v2_mean <- mean(gpp_pred_v2)

gpp_actual_v1_mean <- mean(gpp_actual_v1)
gpp_pred_v1_mean <- mean(gpp_pred_v1)

spatial_performance_v2 <- calc_performance(values(gpp_actual_v2_mean), values(gpp_pred_v2_mean), na.rm = TRUE)
spatial_performance_v1 <- calc_performance(values(gpp_actual_v1_mean), values(gpp_pred_v1_mean), na.rm = TRUE)


# Maps of performance by pixel

fill <- tm_shape(ke_tz, is.main = FALSE) +
  tm_fill(fill = "grey95")
borders <- tm_shape(ke_tz) +
  tm_borders(col = "black")

best_mae <- which.min(c(perf_v1_temporal$mae, perf_v2_temporal$mae, perf_restrend_temporal$mae))
best_rsq <- which.max(c(perf_v1_temporal$rsq, perf_v2_temporal$rsq, perf_restrend_temporal$rsq))

generate_performance_map <- function(performance_rast, metric, palette) {
  # Prep data
  layer <- performance_rast[[metric]]
  
  if (metric == "rsq") {
    negative_rsq <- layer < 0
    negative_rsq <- terra::mask(negative_rsq, negative_rsq, maskvalues = c(0, NA))
  }
  
  label_lookup <- c(
    mae = expression(atop("MAE", (g~C~m^-2~yr^-1))),
    rmse = expression("RMSE ("~g^2~m^-4~yr^-2~")"),
    rsq = expression(R^2)
  )
  
  limits_lookup <- list(
    mae = c(0, 1000),
    rmse = c(0, 1000),
    rsq = c(0, 1)
  )
  
  label <- label_lookup[metric]
  limits <- limits_lookup[[metric]]

  # Prep map
  
  fill <- tm_shape(ke_tz, is.main = FALSE) +
    tm_fill(fill = "grey95")
  borders <- tm_shape(ke_tz) +
    tm_borders(col = "black")
  
  map <- fill +
    tm_shape(layer, is.main = TRUE) +
    tm_raster(
      col.scale = tm_scale_continuous(
        limits = limits,
        values = palette,
        outliers.trunc = c(TRUE, TRUE),
        midpoint = NA
      ),
      col.legend = tm_legend(
        title = label,
        reverse = TRUE,
        frame = FALSE
      )
    ) +
    borders +
    tm_layout(frame = FALSE, asp = 3/4)
  
  if (metric == "rsq" & min(values(layer), na.rm = TRUE) < 0) {
    map <- map +
      tm_shape(negative_rsq) +
      tm_raster(col.scale = tm_scale_categorical(values = c("lightsalmon"), labels = expression(Negative~R^2)),
                col.legend = tm_legend(title = ""))
  }
  
  map
}

rpi_v1_mae_map <- generate_performance_map(perf_v1_temporal, "mae", "or_rd")
rpi_v2_mae_map <- generate_performance_map(perf_v2_temporal, "mae", "or_rd")
restrend_mae_map <- generate_performance_map(perf_restrend_temporal, "mae", "or_rd")
rpi_v1_rsq_map <- generate_performance_map(perf_v1_temporal, "rsq", "viridis")
rpi_v2_rsq_map <- generate_performance_map(perf_v2_temporal, "rsq", "viridis")
restrend_rsq_map <- generate_performance_map(perf_restrend_temporal, "rsq", "or_rd")

# Plot differences in performance between two methods

rpi_mae_diff_map <- fill +
  tm_shape(perf_v2_temporal$mae - perf_v1_temporal$mae, is.main = TRUE) +
  tm_raster(
    col.scale = tm_scale_continuous(
      limits = c(-300, 300), values = "-pu_or", midpoint = 0, outliers.trunc = c(TRUE, TRUE)
    ),
    col.legend = tm_legend(
      reverse = TRUE, title = expression(atop("MAE difference", (g~C~m^-2~yr^-1))), frame = FALSE
    )
  ) +
  borders +
  tm_layout(frame = FALSE, asp = 3/4)
  

rpi_rsq_diff_map <- fill +
  tm_shape(perf_v2_temporal$rsq - perf_v1_temporal$rsq, is.main = TRUE) +
  tm_raster(
    col.scale = tm_scale_continuous(
      limits = c(-0.75, 0.75), values = "pu_or", midpoint = 0, outliers.trunc = c(TRUE, TRUE)
    ),
    col.legend = tm_legend(
      reverse = TRUE, title = expression(R^2~difference), frame = FALSE
    )
  ) +
  borders +
  tm_layout(frame = FALSE, asp = 3/4)

# Best method maps

best_mae_map <- fill +
  tm_shape(best_mae) +
  tm_raster(
    col.scale = tm_scale_discrete(
      ticks = c(1,2,3),
      values = "paired",
      labels = c("RPI v1", "RPI v2", "RESTREND")
    ),
    col.legend = tm_legend(
      title = "Lowest MAE",
      frame = FALSE
    )
  ) +
  borders +
  tm_layout(frame = FALSE, asp = 3/4)

best_rsq_map <- fill +
  tm_shape(best_rsq) +
  tm_raster(
    col.scale = tm_scale_discrete(
      ticks = c(1,2,3),
      values = "paired",
      labels = c("RPI v1", "RPI v2", "RESTREND")
    ),
    col.legend = tm_legend(
      title = expression("Highest"~R^2),
      frame = FALSE
    )
  ) +
  borders +
  tm_layout(frame = FALSE, asp = 3/4)


# Save
tmap_save(rpi_v1_mae_map, "results/figures/rpi_v1_mae_map.png",
          width = 12, height = 12, units = "cm", dpi = 300)
tmap_save(rpi_v2_mae_map, "results/figures/rpi_v2_mae_map.png",
          width = 12, height = 12, units = "cm", dpi = 300)
tmap_save(restrend_mae_map, "results/figures/restrend_mae_map.png",
          width = 12, height = 12, units = "cm", dpi = 300)
tmap_save(rpi_v1_rsq_map, "results/figures/rpi_v1_rsq_map.png",
          width = 12, height = 12, units = "cm", dpi = 300)
tmap_save(rpi_v2_rsq_map, "results/figures/rpi_v2_rsq_map.png",
          width = 12, height = 12, units = "cm", dpi = 300)
tmap_save(restrend_rsq_map, "results/figures/restrend_rsq_map.png",
          width = 12, height = 12, units = "cm", dpi = 300)
tmap_save(rpi_mae_diff_map, "results/figures/rpi_mae_diff_map.png",
          width = 12, height = 12, units = "cm", dpi = 300)
tmap_save(rpi_rsq_diff_map, "results/figures/rpi_rsq_diff_map.png",
          width = 12, height = 12, units = "cm", dpi = 300)
tmap_save(best_mae_map, "results/figures/best_mae_map.png",
          width = 12, height = 12, units = "cm", dpi = 300)
tmap_save(best_rsq_map, "results/figures/best_rsq_map.png",
          width = 12, height = 12, units = "cm", dpi = 300)

## Histograms

temporal_performance_hist_mae <- performance_df %>%
  filter(measure == "mae") %>%
  mutate(version = ordered(version, levels = c("restrend", "v1", "v2"))) %>%
  arrange(version) %>%
  ggplot(aes(x = value, fill = version)) +
  geom_density(alpha = 0.4, kernel = "rectangular") +
  # facet_wrap(~measure, ncol = 1, nrow = 3, scales = "free", labeller = measure_labels) +
  theme_classic() +
  # scale_fill_manual(values = c("orange3", "purple3"), labels = c("RPI v1", "RPI v2", "RESTREND")) +
  scale_fill_brewer(palette = "Dark2", labels = c("RESTREND", "RPI v1", "RPI v2")) +
  coord_cartesian(xlim = c(0, 1500)) +
  geom_vline(xintercept = 0, colour = "grey10") +
  labs(x = expression(MAE~"("~g~C~m^-2~yr^-1~")"), y = "", fill = "Version")

temporal_performance_hist_rsq <- performance_df %>%
  filter(measure == "rsq") %>%
  mutate(version = ordered(version, levels = c("restrend", "v1", "v2"))) %>%
  arrange(version) %>%
  ggplot(aes(x = value, fill = version)) +
  geom_density(alpha = 0.4, kernel = "rectangular") +
  # facet_wrap(~measure, ncol = 1, nrow = 3, scales = "free", labeller = measure_labels) +
  theme_classic() +
  # scale_fill_manual(values = c("orange3", "purple3"), labels = c("RPI v1", "RPI v2", "RESTREND")) +
  scale_fill_brewer(palette = "Dark2", labels = c("RESTREND", "RPI v1", "RPI v2")) +
  coord_cartesian(xlim = c(-0.5, 1)) +
  geom_vline(xintercept = 0, colour = "grey10") +
  labs(x = expression(R^2), y = "", fill = "Version")

ggsave("results/figures/perf_hist_mae.png", temporal_performance_hist_mae,
       width = 12, height = 5, units = "cm", dpi = 300)
ggsave("results/figures/perf_hist_rsq.png", temporal_performance_hist_rsq,
       width = 12, height = 5, units = "cm", dpi = 300)

## Plot overlapping study area

# Calculate overall performance in explaining spatial patterns in mean GPP

v1_sa <- !is.na(rpi_rast_v1$potential_gpp_predicted.2000)
v2_sa <- !is.na(rpi_rast_v2$potential_gpp_predicted.2000)

v2_sa_ext <- extend(v2_sa, v1_sa)
v1_sa_ext <- extend(v1_sa, v2_sa_ext)
overlap <- v1_sa_ext + 2 * v2_sa_ext
overlap_masked <- mask(overlap, overlap, maskvalues = c(0, NA))

levels(overlap_masked) <- data.frame(ID = 1:3, category = c("RPI v1", "RPI v2", "Both versions"))

shared_study_area_map <- fill +
  tm_shape(overlap_masked, is.main = TRUE) +
  tm_raster(
    col.scale = tm_scale_categorical(
      values = "set1",
      # labels = c("RPI v1", "RPI v2", "Both versions")
    ),
  col.legend = tm_legend(title = "Study area", frame = FALSE)
  ) +
  borders

